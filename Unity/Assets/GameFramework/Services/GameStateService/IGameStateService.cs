///////////////////////////////////////////////////////////////////////
//
// WARNING: THIS FILE IS AUTOGENERATED! DO NOT CHANGE IT
//
////////////////////////////////////////////////////////////////////// 

using System;
using System.Collections.Generic;
using MoonSharp.Interpreter;

using static Service.GameStateService.Events;
using UniRx;
using Zenject;
using System.Runtime.Serialization;
using System.Collections.Generic;

namespace Service.GameStateService {
    public interface IGameStateService {



		/// <summary>
        /// Register gamestate with its name. Optionally you can pass an overriden GameState-Classtype of your own 
        /// <param name="name"></param>
        /// <param name="gamestate"></param>
 /// </summary>
        

					GameState RegisterGameState(string name,GameState gamestate=null);


		/// <summary>
        /// Get the current gamestate. Alternatively use "[Inject] GameState current;" 
 /// </summary>
        

					GameState GetCurrentGameState();


		/// <summary>
        /// Start a new gamestate after stopping the current one (if present). Optionally pass a context in which you can e.g. set gamestate-flags 
        /// <param name="gamestate"></param>
        /// <param name="ctx"></param>
 /// </summary>
        

					IObservable<bool> StartGameState(GameState gamestate,GSContext ctx=null);


					IObservable<bool> StopGameState(GameState gamestate);


		/// <summary>
        /// Get gamestate by name 
        /// <param name="name"></param>
 /// </summary>
        

					GameState GetGameState(string name);

	}


    public enum GSStatus {
        noneStatus,starting,running,closing
        
    }


    [DataContract(IsReference = true)]
    [System.Serializable]
    public partial class GSContext {

    }

}
///////////////////////////////////////////////////////////////////////
//
// WARNING: THIS FILE IS AUTOGENERATED! DO NOT CHANGE IT
//
////////////////////////////////////////////////////////////////////// 
